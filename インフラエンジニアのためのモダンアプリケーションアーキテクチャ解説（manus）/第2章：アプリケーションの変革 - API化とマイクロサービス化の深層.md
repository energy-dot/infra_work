## 第2章：アプリケーションの変革 - API化とマイクロサービス化の深層

前章では、ビジネスの変化とテクノロジーの追従、そしてアプリケーションアーキテクチャの変遷を概観し、インフラエンジニアにとっての変革の必要性を確認しました。本章では、その変革の中核をなす「API化」と「マイクロサービス化」というアプリケーション側の動きに焦点を当て、その背景、設計原則、そしてサービス間連携のあり方について深掘りしていきます。インフラエンジニアがこれらの概念を理解することは、モダンなインフラを設計・構築・運用する上で不可欠な前提知識となります。

### 2.1. モノリスからの脱却とマイクロサービスの台頭

なぜ、かつて主流であったモノリシックアーキテクチャから、マイクロサービスアーキテクチャへと移行する動きが加速しているのでしょうか。その背景には、ビジネス環境の要求と技術的進化が複雑に絡み合っています。

**モノリシックアーキテクチャが抱える根本的な課題**

第1章でも触れましたが、モノリシックアーキテクチャは、アプリケーションの全ての機能が一つの大きな塊として結合しているため、規模が大きくなるにつれて以下のような深刻な課題に直面します。

*   **開発効率の著しい低下**: 機能追加や修正が他の部分に予期せぬ影響を与えるリスクが高く、テスト範囲も広範囲に及びます。結果として、開発チームの規模が大きくなるほどコミュニケーションコストが増大し、一人ひとりの生産性が低下。リリースサイクルも長期化し、ビジネスの要求スピードに追いつけなくなります。
*   **スケーラビリティの限界とリソース非効率**: 特定の機能（例えば、ECサイトの商品検索機能）だけにアクセスが集中した場合でも、モノリス全体を複製してスケールアウトする必要があり、リソース効率が悪化します。また、データベースも単一であることが多く、そこがボトルネックになることも少なくありません。
*   **技術的負債の蓄積とイノベーションの阻害**: 全体で単一の技術スタック（プログラミング言語、フレームワーク、ライブラリ）を採用する必要があるため、新しい技術の導入や部分的な刷新が非常に困難です。結果として、古い技術に縛られ続け、技術的負債が雪だるま式に増加し、イノベーションの足かせとなります。
*   **デプロイリスクの増大**: 小さな変更であっても、アプリケーション全体をデプロイし直す必要があり、デプロイ作業そのものが高リスクなイベントとなります。万が一デプロイに失敗した場合、システム全体が停止する可能性も否定できません。
*   **障害耐性の低さ**: 一つのモジュールのバグやリソースリークが、アプリケーション全体のパフォーマンス低下や障害を引き起こす可能性があります。

これらの課題は、特に変化の速い現代のビジネス環境において、企業が競争力を維持し、成長を続ける上で大きな障害となります。

**マイクロサービスが提供する価値**

マイクロサービスアーキテクチャは、これらのモノリシックな課題に対する解決策として登場しました。アプリケーションを、ビジネスドメインに基づいて独立して開発・デプロイ・スケーリング可能な小さな「サービス」の集合体として構築することで、以下のような価値を提供します。

*   **俊敏性の向上 (Agility)**: 各サービスは比較的小さなコードベースを持ち、独立したチームが担当できるため、開発・テスト・デプロイのサイクルを高速化できます。これにより、新機能の市場投入までの時間を大幅に短縮し、ビジネスの変化に迅速に対応できます。
*   **独立性と障害分離 (Independence & Fault Isolation)**: 各サービスは独立してデプロイ・運用されるため、あるサービスでの障害が他のサービスに波及しにくくなります。また、サービスごとに最適な技術スタックを選択できるため、技術的な柔軟性が向上します。
*   **スケーラビリティの最適化 (Scalability)**: 各サービスを個別にスケールアウト/インできるため、リソースを効率的に利用できます。例えば、特定のキャンペーンでアクセスが急増する注文サービスだけを一時的に強化するといった対応が可能です。
*   **技術選択の自由度 (Technology Diversity)**: 各サービスに最適なプログラミング言語、フレームワーク、データストアを選択できます（ポリグロットプログラミング、ポリグロットパーシステンス）。これにより、特定の技術にロックインされるリスクを低減し、新しい技術の採用も容易になります。
*   **チームの自律性と所有権 (Team Autonomy & Ownership)**: 各サービスを専門の小規模チーム（いわゆる「Two Pizza Team」）が開発から運用まで責任を持つことで、チームのモチベーション向上と迅速な意思決定を促進します。

もちろん、マイクロサービスアーキテクチャも銀の弾丸ではなく、分散システム特有の複雑性（サービス間通信、データ整合性、運用監視など）という新たな課題も伴います。しかし、適切に設計・運用されれば、ビジネスの成長とイノベーションを加速させる強力な武器となり得ます。

### 2.2. マイクロサービスの設計原則と実践

効果的なマイクロサービスアーキテクチャを構築するためには、いくつかの重要な設計原則と実践的なアプローチを理解しておく必要があります。

**ドメイン駆動設計（DDD）と境界づけられたコンテキスト（Bounded Context）**

マイクロサービスをどのように分割するかは、アーキテクチャ全体の成否を左右する重要な決定です。ここで強力な指針となるのが、「ドメイン駆動設計（DDD: Domain-Driven Design）」というソフトウェア設計手法です。DDDは、複雑なビジネスドメイン（業務領域）を深く理解し、その構造をソフトウェアモデルに反映させることを目指します。

DDDの中心的な概念の一つが「境界づけられたコンテキスト（Bounded Context）」です。これは、特定のドメインモデルが明確な意味を持つ範囲（境界）を定義するものです。例えば、Eコマースシステムにおいて、「商品」という言葉は、在庫管理コンテキストでは「物理的な在庫単位」を指し、カタログコンテキストでは「顧客に表示される情報」を指すかもしれません。このように、同じ言葉でもコンテキストによって意味合いが異なることを認識し、各コンテキスト内で一貫したモデルを構築します。

マイクロサービスの分割は、この境界づけられたコンテキストを基準に行うことが推奨されます。つまり、一つの境界づけられたコンテキストが一つのマイクロサービスに対応するように設計することで、サービス間の結合度を低く保ち、各サービスがビジネス的に意味のある単位として自律的に機能できるようになります。

**サービスの適切な分割粒度と独立性の確保**

サービスの分割粒度は、「マイクロ」という言葉に惑わされず、小さすぎず大きすぎない適切なサイズを見極めることが重要です。小さすぎるサービスは、サービス間の通信オーバーヘッドを増大させ、システム全体の複雑性を不必要に高める可能性があります。逆に大きすぎるサービスは、モノリスの課題を再び抱え込むことになりかねません。

適切な粒度を判断する基準としては、以下の点が挙げられます。

*   **単一責任の原則 (Single Responsibility Principle)**: 各サービスは、明確に定義された一つのビジネス機能またはビジネス能力に責任を持つべきです。
*   **変更容易性**: 一つのビジネス要件の変更が、複数のサービスにまたがって修正を必要とする場合、分割が適切でない可能性があります。
*   **チームの規模と能力**: 一つのチームが責任を持って開発・運用できる範囲であること。
*   **独立したデプロイメント**: 他のサービスとは独立してデプロイ可能であること。
*   **データの独立性**: 可能であれば、各サービスが独自のデータストアを持つこと。

サービスの独立性を確保するためには、サービス間の直接的な同期呼び出しを最小限に抑え、非同期メッセージングなどを活用することも有効です。また、共有ライブラリや共有データベースといった暗黙的な結合にも注意が必要です。

**データ管理戦略**

マイクロサービスアーキテクチャにおけるデータ管理は、モノリシックアーキテクチャとは大きく異なります。最も重要な原則は「データベース・パー・サービス（Database per Service）」です。これは、各マイクロサービスが自身のデータを所有し、他のサービスはそのデータに直接アクセスせず、必ずAPIを通じてアクセスするという考え方です。

これにより、各サービスは自身のデータモデルやストレージ技術（リレーショナルデータベース、NoSQLデータベースなど）を自由に選択でき、他のサービスからの影響を受けずにスキーマ変更などを行えるようになります。しかし、このアプローチは分散トランザクションの管理という新たな課題を生み出します。

複数のサービスにまたがるビジネスプロセス（例えば、注文処理において、注文サービス、在庫サービス、決済サービスが連携するケース）で一貫性を保つためには、従来のようなACIDトランザクションに頼ることは困難です。代わりに、「結果整合性（Eventual Consistency）」という考え方や、それを実現するためのパターンとして「Sagaパターン」などが用いられます。

*   **結果整合性**: システム全体が最終的には一貫した状態に収束すればよいという考え方。一時的に不整合な状態を許容します。
*   **Sagaパターン**: 一連のローカルトランザクションのシーケンスとしてビジネスプロセスを実装するパターン。各ローカルトランザクションが完了すると、次のローカルトランザクションをトリガーするイベントを発行します。途中で失敗した場合は、それまでの処理を取り消すための補償トランザクションを実行します。

これらのデータ管理戦略は、インフラエンジニアにとっても、データベースの選定、レプリケーション設定、バックアップ戦略、そして障害時のデータ復旧手順などを検討する上で重要な考慮事項となります。

### 2.3. APIエコノミーとサービス間連携

マイクロサービスアーキテクチャでは、各サービスはAPIを通じて互いに連携します。このAPIは、サービス間の契約（コントラクト）として機能し、明確に定義され、安定している必要があります。APIを中心としたシステム設計は、社内外のシステム連携を促進し、「APIエコノミー」と呼ばれる新たな経済圏の形成にもつながっています。

**同期通信と非同期通信**

サービス間の連携方法には、大きく分けて同期通信と非同期通信があります。

*   **同期通信 (Synchronous Communication)**: クライアントがリクエストを送信し、サーバーからのレスポンスを待機する方式です。代表的なものに、HTTP/RESTやgRPCがあります。
    *   **HTTP/REST**: Webの標準プロトコルであるHTTPを利用し、リソース指向の考え方で設計されます。JSON形式のデータをやり取りすることが一般的です。シンプルで理解しやすく、多くの言語やフレームワークでサポートされています。
    *   **gRPC**: Googleが開発したRPC（Remote Procedure Call）フレームワークです。HTTP/2をベースとし、Protocol Buffersというシリアライズ形式を使用します。型付けされたインターフェース定義が可能で、パフォーマンスが高く、双方向ストリーミングなどの高度な機能もサポートします。主にマイクロサービス間の内部通信で利用されます。
    同期通信は、リクエストの結果をすぐに知りたい場合に適していますが、呼び出し先のサービスが応答しない場合、呼び出し元がブロックされてしまうという欠点があります。これにより、システム全体のレイテンシ増加や可用性低下につながる可能性があります。

*   **非同期通信 (Asynchronous Communication)**: クライアントがリクエスト（メッセージ）を送信した後、サーバーからの即時レスポンスを待たずに他の処理を続ける方式です。メッセージキューイングシステム（例：Apache Kafka, RabbitMQ, AWS SQS）を利用することが一般的です。
    クライアントはメッセージをキューに送信し、サーバー（コンシューマー）は自身のペースでキューからメッセージを取得して処理します。これにより、サービス間の時間的な結合が分離され、システムの耐障害性やスケーラビリティが向上します。例えば、注文処理サービスが注文イベントをメッセージキューに発行し、在庫管理サービスや通知サービスがそれを非同期に処理するといった構成が考えられます。
    非同期通信は、即時性が求められない処理や、バッチ処理、イベント駆動型のアーキテクチャに適しています。

**APIゲートウェイの役割と重要性**

マイクロサービスアーキテクチャでは、多数のサービスが外部（クライアントアプリケーションやサードパーティシステム）にAPIを公開することになります。しかし、クライアントが個々のサービスエンドポイントを直接呼び出すのは、以下のような理由で現実的ではありません。

*   クライアント側の実装が複雑になる。
*   サービスのエンドポイント変更がクライアントに影響を与える。
*   認証・認可、レートリミット、ロギングといった共通処理を各サービスで実装する必要があり非効率。

そこで登場するのが「APIゲートウェイ」です。APIゲートウェイは、全てのクライアントリクエストに対する単一のエントリーポイントとして機能し、リクエストを適切なバックエンドサービスにルーティングします。APIゲートウェイは、以下のような重要な役割を担います。

*   **リクエストルーティング**: クライアントからのリクエストを、パスやヘッダー情報に基づいて適切なマイクロサービスに振り分けます。
*   **認証・認可**: クライアントの認証を行い、リクエストされた操作を実行する権限があるかを確認します。
*   **レートリミットとクォータ管理**: 特定のクライアントやAPIからの過度なリクエストを防ぎ、システムの安定性を保ちます。
*   **リクエスト/レスポンス変換**: 必要に応じて、クライアントとバックエンドサービス間でデータ形式の変換を行います。
*   **キャッシング**: よくアクセスされるレスポンスをキャッシュし、バックエンドサービスの負荷を軽減します。
*   **ロギングとモニタリング**: APIの利用状況やエラーを記録し、監視します。
*   **APIバージョニング**: 複数のバージョンのAPIを共存させ、段階的な移行を支援します。

APIゲートウェイは、AWS API Gateway, Azure API Management, Google Cloud API Gatewayといったクラウドプロバイダーのマネージドサービスや、Kong, Tykといったオープンソースソフトウェアを利用して構築できます。インフラエンジニアは、APIゲートウェイの選定、設計、運用において中心的な役割を果たします。

**サービスディスカバリの仕組み**

マイクロサービス環境では、各サービスインスタンスのIPアドレスやポート番号は、オートスケーリングやデプロイメントによって動的に変化します。そのため、クライアントや他のサービスが、目的のサービスインスタンスをどのように見つけるかという「サービスディスカバリ」の仕組みが不可欠です。

サービスディスカバリには、主に以下の2つのパターンがあります。

*   **クライアントサイドディスカバリ**: クライアントがサービスレジストリ（例：Consul, etcd, Zookeeper, Netflix Eureka）に問い合わせ、利用可能なサービスインスタンスのリストを取得し、自身でロードバランシングを行います。
*   **サーバーサイドディスカバリ**: クライアントはロードバランサー（APIゲートウェイや専用のロードバランサー）にリクエストを送信し、ロードバランサーがサービスレジストリと連携して適切なサービスインスタンスにリクエストを転送します。

コンテナオーケストレーションプラットフォームであるKubernetesは、DNSベースのサービスディスカバリ機能を組み込みで提供しており、多くの場合これが利用されます。インフラエンジニアは、サービスディスカバリの仕組みを理解し、適切に設定・運用することが求められます。

本章では、アプリケーションがAPI化・マイクロサービス化する背景と、その設計原則、そしてサービス間連携の技術について解説しました。次章では、これらのモダンなアプリケーションアーキテクチャを支えるインフラストラクチャ技術について、より深く掘り下げていきます。

